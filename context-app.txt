// File: package.json
{
  "name": "inicioapp-backend",
  "module": "src/server.ts",
  "type": "module",
  "scripts": {
    "dev": "bun --watch src/server.ts",
    "start": "bun src/server.ts"
  },
  "devDependencies": {
    "@types/bun": "latest",
    "@types/xml2js": "^0.4.14",
    "typescript": "^5.0.0"
  },
  "peerDependencies": {
    "typescript": "^5.7.3"
  },
  "dependencies": {
    "@elysiajs/cors": "^1.2.0",
    "elysia": "^1.2.10",
    "firebase-admin": "^13.0.2",
    "googleapis": "^144.0.0",
    "xml2js": "^0.6.2"
  }
}

// File: README.md
# InicioApp Backend

Este es el backend de la aplicaci칩n InicioApp, desarrollado con **Bun** y **ElysiaJS**. Proporciona una API para la gesti칩n de marcadores y la autenticaci칩n de usuarios.

## Caracter칤sticas

*   **Autenticaci칩n con Firebase:** Los usuarios se autentican a trav칠s de Firebase Authentication, utilizando Google como proveedor.
*   **Obtenci칩n de marcadores:** La API permite obtener la estructura de carpetas y marcadores del usuario desde un archivo `bookmarks.xbel` almacenado en Google Drive.
*   **Transformaci칩n de XML a JSON:** El archivo `bookmarks.xbel` (en formato XML) se transforma a un formato JSON m치s manejable para el frontend.
*   **Copia local de marcadores:** El backend guarda una copia local de los marcadores en formato JSON (`bookmarks.json`) para mejorar el rendimiento y servir como respaldo en caso de fallos al acceder a Google Drive.
*   **Manejo de errores:** El backend maneja los errores y devuelve respuestas con c칩digos de estado HTTP apropiados.
*   **Soporte CORS:**  Configurado para permitir peticiones desde cualquier origen (configurable para mayor seguridad en producci칩n).

## Requisitos

*   [Bun](https://bun.sh/) (v1.0.0 o superior)
*   Cuenta de Google
*   Proyecto en Firebase con la autenticaci칩n de Google habilitada.
*   Cuenta de servicio en Google Cloud Platform con acceso de lectura a Google Drive.
*   Archivo `bookmarks.xbel` en Google Drive compartido con la cuenta de servicio.

## Configuraci칩n

1. **Clonar el repositorio:**

    ```bash
    git clone <URL del repositorio>
    cd inicioapp-backend
    ```

2. **Instalar dependencias:**

    ```bash
    bun install
    ```

3. **Configurar variables de entorno:**

    *   Crea un archivo `.env` en la ra칤z del proyecto.
    *   A침ade las siguientes variables de entorno:

        ```
        FIREBASE_ADMINSDK_PATH=./ruta/al/archivo/firebase-adminsdk.json
        GOOGLE_CREDENTIALS_PATH=./ruta/al/archivo/google-credentials.json
        ```

        *   `FIREBASE_ADMINSDK_PATH`: Ruta al archivo JSON de la clave privada de Firebase Admin SDK. Puedes descargarlo desde la consola de Firebase en la configuraci칩n del proyecto -> Cuentas de servicio.
        *   `GOOGLE_CREDENTIALS_PATH`: Ruta al archivo JSON de la clave privada de la cuenta de servicio de Google Cloud. Puedes descargarlo desde la consola de Google Cloud en IAM y administraci칩n -> Cuentas de servicio.

4. **Configurar `bookmarks.json`:**

    *   Crea un archivo vac칤o llamado `bookmarks.json` en la ra칤z del proyecto. Este archivo se usar치 para almacenar una copia local de los marcadores.

5. **Compartir el archivo `bookmarks.xbel`:**
    *   Sube tu archivo `bookmarks.xbel` a Google Drive.
    *   Comparte el archivo con la direcci칩n de correo electr칩nico de la cuenta de servicio (la que aparece en el archivo `google-credentials.json` en el campo `client_email`). Dale permisos de **Lector**.

## Ejecutar el backend

```bash
bun run dev
Use code with caution.
Esto iniciar치 el servidor de desarrollo de Elysia en http://localhost:3000.

Rutas
GET /: Devuelve un mensaje de bienvenida.

POST /auth/verify: Verifica el token de autenticaci칩n de Firebase enviado por el frontend.

Request:

{
  "token": "TOKEN_DE_FIREBASE"
}
Use code with caution.
Json
Response (칠xito):

{
  "status": "success",
  "user": {
    // Datos del usuario de Firebase
  }
}
Use code with caution.
Json
Response (error):

{
  "status": "error",
  "message": "Invalid token"
}
Use code with caution.
Json
GET /bookmarks: Devuelve la estructura de carpetas y marcadores en formato JSON.

Tecnolog칤as
Bun: Runtime de JavaScript r치pido y moderno.

ElysiaJS: Framework web para Bun, r치pido y f치cil de usar.

Firebase Admin SDK: Para la autenticaci칩n de usuarios.

Google Cloud Client Libraries for Node.js: Para interactuar con Google Drive.

xml2js: Para parsear el archivo XML de marcadores.

Notas
Este backend est치 configurado para permitir peticiones desde cualquier origen (CORS). En un entorno de producci칩n, se recomienda restringir los or칤genes permitidos.

La funcionalidad para gestionar favoritos a칰n no est치 implementada.

Contribuciones
Las contribuciones son bienvenidas. Por favor, abre un issue o env칤a un pull request.

// File: tsconfig.json
{
  "compilerOptions": {
    "lib": ["ESNext"],
    "module": "esnext",
    "target": "esnext",
    "moduleResolution": "bundler",
    "moduleDetection": "force",
    "allowImportingTsExtensions": true,
    "noEmit": true,
    "composite": true,
    "strict": true,
    "downlevelIteration": true,
    "skipLibCheck": true,
    "jsx": "react-jsx",
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "allowJs": true,
    "types": [
      "bun-types" // add Bun global
    ]
  }
}

// File: src\app.ts
import { Elysia, t } from "elysia";
import { cors } from "@elysiajs/cors";
import { verifyToken } from "./services/auth.service";
import { getBookmarks } from "./controllers/bookmarks.controller";

// ---------- Esquemas de validaci칩n ----------

const VerifyTokenSchema = t.Object({
  token: t.String(),
});

// ---------- Funciones auxiliares para el manejo de errores ----------

const handleSuccess = (data: any, status: number = 200) => ({
  status: "success",
  data,
});

const handleError = (message: string, status: number = 500) => ({
  status: "error",
  message,
});

// ---------- Aplicaci칩n Elysia ----------

export const app = new Elysia()
  .use(cors()) // Habilita CORS para todos los or칤genes
  .get("/", () => handleSuccess({ message: "Welcome to InicioApp Backend!" }))
  .group("/auth", (app) =>
    app.post(
      "/verify",
      async ({ body, set }) => {
        try {
          const user = await verifyToken(body.token);
          console.log("Token verified successfully:", user);
          return handleSuccess({ user });
        } catch (error) {
          console.error("Error verifying token:", error);
          set.status = 401;
          return handleError("Invalid token", 401);
        }
      },
      { body: VerifyTokenSchema }
    )
  )
  .group("/bookmarks", (app) =>
    app.get("/", async ({ set }) => {
      try {
        const bookmarks = await getBookmarks();
        console.log("Bookmarks fetched successfully.");
        return handleSuccess({ bookmarks });
      } catch (error) {
        console.error("Error fetching bookmarks:", error);
        set.status = 500;
        return handleError("Failed to fetch bookmarks", 500);
      }
    })
  );

// File: src\server.ts
import { app } from "./app";
import { Elysia } from "elysia";
import { loadBookmarks } from "./services/cache.service";

const port = 3000;

async function startServer() {
  // Cargar los marcadores al iniciar el servidor (antes de escuchar peticiones)
  await loadBookmarks();
  app.listen(port);
  console.log(
    `游붉 Elysia is running at ${app.server?.hostname}:${app.server?.port}`
  );
}

function getProtocol(app: Elysia): string {
  if ((app.server as any)?.secure) {
    return "https";
  } else {
    return "http";
  }
}

startServer();

// File: src\controllers\bookmarks.controller.ts
import {
  loadBookmarks,
  cachedBookmarks,
} from "../services/cache.service";

export async function getBookmarks() {
  // Si los marcadores no est치n en la cach칠, los carga (desde el archivo local o Google Drive)
  if (!cachedBookmarks) {
    await loadBookmarks();
  }
  // Devuelve los marcadores desde la cach칠
  return cachedBookmarks;
}

// File: src\controllers\favorites.controller.ts
import { promises as fs } from "fs";

const favoritesFile = "./favorites.json"; // Ruta al archivo de favoritos

export async function saveFavorites(favorites: any[]) {
  try {
    await fs.writeFile(favoritesFile, JSON.stringify(favorites, null, 2));
    console.log("Favorites saved successfully to:", favoritesFile);
  } catch (error) {
    console.error("Error saving favorites:", error);
    throw error; // Lanzar el error para que se maneje en la ruta
  }
}

export async function loadFavorites() {
  try {
    const data = await fs.readFile(favoritesFile, "utf-8");
    const favorites = JSON.parse(data);
    console.log("Favorites loaded successfully from:", favoritesFile);
    return favorites;
  } catch (error) {
    console.error("Error loading favorites:", error);
    return []; // Devolver un array vac칤o si hay un error (por ejemplo, si el archivo no existe)
  }
}

// File: src\services\auth.service.ts
import admin from "firebase-admin";
import { getAuth, DecodedIdToken } from 'firebase-admin/auth';

const serviceAccount = Bun.file(process.env.FIREBASE_ADMINSDK_PATH!);

admin.initializeApp({
  credential: admin.credential.cert(await serviceAccount.json()),
});

export async function verifyToken(token: string): Promise<DecodedIdToken> {
  const decodedToken = await getAuth().verifyIdToken(token);
  return decodedToken;
}

// File: src\services\cache.service.ts
import { promises as fs } from "fs";
import { getBookmarksData } from "./drive.service";
import { parseXMLToJSON } from "../utils/xmlParser";

const bookmarksFile = "./bookmarks.json";

// Variable global para almacenar los marcadores en memoria
export let cachedBookmarks: any = null;

export async function loadBookmarks() {
  try {
    // Intenta cargar desde el archivo local primero
    const localBookmarks = await loadBookmarksFromLocalFile();
    if (localBookmarks) {
      cachedBookmarks = localBookmarks;
      console.log("Bookmarks loaded from local file.");
      return;
    }

    // Si no hay copia local, obtiene los datos de Google Drive
    console.log("Getting bookmarks data from drive service...");
    const xmlData = await getBookmarksData();

    console.log("Parsing XML to JSON...");
    const jsonData = await parseXMLToJSON(xmlData);
    console.log("XML parsed to JSON successfully.");

    cachedBookmarks = jsonData;
    await saveBookmarksToLocalFile(jsonData);
  } catch (error) {
    console.error("Error loading bookmarks:", error);
    throw error;
  }
}

async function saveBookmarksToLocalFile(bookmarks: any) {
  try {
    await fs.writeFile(bookmarksFile, JSON.stringify(bookmarks, null, 2));
    console.log("Bookmarks saved to local file successfully.");
  } catch (error) {
    console.error("Error saving bookmarks to local file:", error);
    throw error;
  }
}

async function loadBookmarksFromLocalFile() {
  try {
    const data = await fs.readFile(bookmarksFile, "utf-8");
    const bookmarks = JSON.parse(data);
    console.log("Bookmarks loaded from local file successfully.");
    return bookmarks;
  } catch (error) {
    console.error("Error loading bookmarks from local file:", error);
    return null;
  }
}

async function createBookmarksFileIfNotExists() {
  try {
    await fs.access(bookmarksFile);
    console.log("Bookmarks file exists.");
  } catch (error: any) {
    if (error.code === "ENOENT") {
      console.log("Bookmarks file does not exist. Creating...");
      await saveBookmarksToLocalFile([]);
      console.log("Bookmarks file created.");
    } else {
      console.error("Error accessing bookmarks file:", error);
      throw error;
    }
  }
}

// Aseg칰rate de que el archivo exista al iniciar
createBookmarksFileIfNotExists();

// File: src\services\drive.service.ts
import { google, type drive_v3 } from "googleapis";

const credentials = Bun.file(process.env.GOOGLE_CREDENTIALS_PATH!);

const auth = new google.auth.GoogleAuth({
  credentials: await credentials.json(),
  scopes: ["https://www.googleapis.com/auth/drive.readonly"],
});

const drive = google.drive({ version: "v3", auth });

async function getFileContent(fileId: string): Promise<string> { // Se especifica el tipo de retorno como Promise<string>
  try {
    console.log(`Getting content of file with ID: ${fileId}`);
    const response = await drive.files.get(
      { fileId, alt: "media" },
      { responseType: "text" } // Forzar que la respuesta sea de tipo texto
    );
    console.log("File content fetched successfully.");
    return response.data as string; // Se devuelve la propiedad data como string
  } catch (error) {
    console.error("Error getting file content:", error);
    throw error;
  }
}

export async function findBookmarksFile(): Promise<string> { // Aseg칰rate de que la funci칩n devuelve una Promesa que resuelve a un string
  try {
    console.log("Finding bookmarks file...");
    const response = await drive.files.list({
      q: "name='bookmarks.xbel'",
      fields: "files(id, name)",
    });
    const files = response.data.files;
    if (files && files.length > 0) {
      console.log("Bookmarks file found:", files[0].id);
      return files[0].id!; // Devuelve el ID del archivo
    } else {
      console.error("Bookmarks file not found.");
      throw new Error("Bookmarks file not found");
    }
  } catch (error) {
    console.error("Error finding bookmarks file:", error);
    throw error;
  }
}

export async function getBookmarksData(): Promise<string> { // Se especifica el tipo de retorno como Promise<string>
  try {
    console.log("Getting bookmarks data...");
    const fileId = await findBookmarksFile(); // Obtiene el ID del archivo
    const fileContent = await getFileContent(fileId); // Obtiene el contenido del archivo usando el ID
    console.log("Bookmarks data fetched successfully.");
    return fileContent; // Devuelve el contenido del archivo
  } catch (error) {
    console.error("Error getting bookmarks data:", error);
    throw error;
  }
}

// File: src\utils\xmlParser.ts
import { parseStringPromise } from "xml2js";

export async function parseXMLToJSON(xml: string) {
  try {
    console.log("Parsing XML to JSON...");
    const result = await parseStringPromise(xml);
    console.log("XML parsed to JSON successfully.");
    return transformBookmarks(result.xbel); // Accede a la ra칤z xbel
  } catch (error) {
    console.error("Error parsing XML to JSON:", error);
    throw error;
  }
}

function transformBookmarks(data: any): any {
  // console.log("Transforming:", JSON.stringify(data, null, 2));

  if (data.folder) {
    return data.folder.map((folder: any) => ({
      title: folder.title[0],
      type: "folder",
      children: folder.bookmark
        ? folder.bookmark
            .map((bookmark: any) => ({
              title: bookmark.title[0],
              url: bookmark.$.href,
              type: "bookmark",
            }))
            .concat(
              folder.folder ? transformBookmarks(folder) : []
            )
        : folder.folder
        ? transformBookmarks(folder)
        : [],
    }));
  } else if (data.bookmark) {
    return data.bookmark.map((bookmark: any) => ({
      title: bookmark.title[0],
      url: bookmark.$.href,
      type: "bookmark",
    }));
  } else {
    console.log("Unknown element type:", data);
    return [];
  }
}

